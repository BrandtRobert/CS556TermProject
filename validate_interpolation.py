import argparse
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


def remove_rows(df: pd.Series, keep=2, remove=6):
    df_copy = df.copy()
    counter = 0
    for idx, row in df.iteritems():
        if counter < keep:
            pass
        # Ex: keep = 2, remove = 3. If counter is between 2 (inclusive) and 5 (exclusive) remove row
        elif counter < keep + remove:
            df_copy[idx] = np.nan
        else:
            counter = 0
        counter += 1

    return df_copy


def main():
    parser = argparse.ArgumentParser(description='Does statistical analysis on '
                                                 'interpolation techniques for dataset values')
    parser.add_argument('input_csv', metavar='[Input Data Set]', type=str, default='merged.csv',
                        help='The name of the merged PGN file')
    parser.add_argument('spn_file', type=str, help='A file contain SPNPGN combos')
    parser.add_argument('output_file', type=str, help='Name of the stats file')
    parser.add_argument('--graph_spn_pgn', type=str, help='Graph this spn/pgn code', default=None)

    args = parser.parse_args()

    graph_spn = args.graph_spn_pgn

    input_file = args.input_csv
    spn_file = args.spn_file
    output_file = args.output_file

    file_pgn = input_file.split('-')[1]

    # Grab spns for our specific file, generated by ExtractPGNSPN.py
    # spn_list could also be hard coded ex; ['F003:55, 'F003:559', 'F003:1437', 'F003:2970']
    # F00E:3216
    spns_list = []
    for line in open(spn_file).readlines():
        pgn = line[:-1].split(':')[0]
        if pgn == file_pgn[:4]:
            spns_list.append(line[:-1])

    original_df: pd.DataFrame = pd.read_csv(input_file)
    # Strip whitespace from column names
    original_df = original_df.rename(columns=lambda x: x.strip())

    mean_sqd_errors = [] * len(spns_list)
    mean_abs_errors = [] * len(spns_list)
    std_deviations = [] * len(spns_list) # std dev of the original data

    print('Running interpolation experiments...')
    print('Method -- Linear Interpolation')
    for pgn_spn in spns_list:
        spn_series: pd.Series = original_df[pgn_spn]
        modified_series = remove_rows(spn_series)
        # Randomly remove half of the values
        # modified_series: pd.DataFrame = spn_series.copy()
        # rm_indexes = np.random.choice(modified_series.index.values, size=(modified_series.shape[0] // 10))
        # modified_series[modified_series.index.isin(rm_indexes)] = np.nan

        # Backward interpolation requires you to place a limit on the number of interpolations
        # We have to do this since we are going in both forward and backward directions
        lim = modified_series.shape[0]
        modified_series = modified_series.interpolate(method='linear', limit=lim, limit_direction='both')

        # Compared the difference between the reconstructed and actual
        modified_series: np.array = modified_series.to_numpy()
        spn_series: np.array = spn_series.to_numpy()

        print(pgn_spn)
        if graph_spn is not None and pgn_spn == graph_spn:
            plt.plot(spn_series[:100], label='actual')
            plt.plot(modified_series[:100], label='interpolated')
            plt.title(graph_spn)
            plt.legend(loc='upper right')
            plt.show()

        mean_sqd_errors.append(np.mean(np.square(spn_series - modified_series)))
        mean_abs_errors.append(np.mean(np.abs(spn_series - modified_series)))
        std_deviations.append(np.std(spn_series))

    print('Outputting data to file {}'.format(output_file))
    with open(output_file, 'w') as stat_file:
        for idx, spn in enumerate(spns_list):
            print('{}, mse: {:.4f}, mae: {:.4f}, std: {:.4f}'
                  .format(spn, mean_sqd_errors[idx], mean_abs_errors[idx], std_deviations[idx]), file=stat_file)
        stat_file.close()


if __name__ == "__main__":
    main()

